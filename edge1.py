# -*- coding: utf-8 -*-
"""edge1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Qc5er-fZuFHMzSVV6PCFD17cEpHkn3f9
"""

import heapq
import time 
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import random

edges = []                        #edge servers 
iots=[]                           #iots devices
for i in range(0,4):             
    edges.append("edge" + str(i))                 
    
    
for i in range(0,20):
    iots.append("iot" + str(i+4))
    
print("iots: ",iots)
print("edges: ",edges)

### INPUTS###

avg_pkt_size=8000       #packet size in bits
max_thres=85000*avg_pkt_size # bits 85000*8000 =680000000 bits
                             #maximum load that one edge can take is "max_thres"




frequency=2.4*10**9    # standard frequency of AODV protocol
datarate= 54*10**6     # standard datarate at which data can be transmitted,
                       #unit of datarate bits/sec
# Different Variables , list , dictionary are initialized here                       
extraload = {"edge1" : [], "edge2" : [],"edge3" : [],"edge4" : []}  #extraload on edges, 
                                                                    #exceeding, maximum threshold  
edgelist = ["edge1","edge2","edge3","edge4"]     
remaining_capacity_ofedges = {}                  #remaining space
t0 = 0 # starting time   

print("\n")
print("EDGE1")

class edge1:
  ####edge1#####
  # 4 iots joining to edge1
  tjoin_edge1 = [20,30,35,40]   #joining times of iots to edge1 
  tsend_edge1 = []               #time taken to send/receive  required data from different iots to EDGE1. 

  for i in range(0,4):                   
    
    tsend_edge1.append(random.randint(1,300*10**6)/datarate)    # total time to send/receive  the desired data from different iots
    
  print("time taken to send/receive data to edge1 ",tsend_edge1)      
    
  tfinal_edge1 = []           #final time when tcp connection stops
  for i in range(0,4):
    tfinal_edge1.append(tsend_edge1[i] + tjoin_edge1[i])     
    
  load_edge1 = []                      #load due to each iot on edge1

  print("final time of iots which are connected to edge1: ",tfinal_edge1)

  for i in range(0,4):
    load_edge1.append(int(datarate*(tfinal_edge1[i]-tjoin_edge1[i])))  

  print("iots to connect to edge1: ",load_edge1)
      
  total_load_edge1 = 0
  #summation of all loads contributed by all iots connected to edge1
  for i in range(0,4):
    if(total_load_edge1 < max_thres and load_edge1[i] <= (max_thres - total_load_edge1)): #checking threshold condn
      total_load_edge1 += load_edge1[i]
      
    else:
        print("load exceeded at edge1, connecting to some other edge")
        extraload["edge1"].append(load_edge1[i]) 
      
  edgeload = total_load_edge1     # total load on edge1    
  print("total load on edge1: ",edgeload)    
    
  print("extraload: ",extraload)   
  print("maximum threshold of edge1",max_thres)
  load1 = max_thres - total_load_edge1          #remaining capacity(load taking)  of edge1

  print("\n")